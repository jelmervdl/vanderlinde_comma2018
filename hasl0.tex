HASL/0 is an implementation of the language which focusses on supporting all elements of the argument structure. Combining sentences (or structures) in to larger arguments is done by repeating the premise, not unlike repeating a variable in first-order logic.

\paragraph{Parser} Sentences are tokenized and to each of the tokens a part-of-speech tag (pos-tag) is assigned using spaCy. The tokens are then parsed into argument structures using an Earley parser and the grammar described in this section.

\paragraph{Argument structure} The partial and final argument structures are represented as a graph with nodes and edges, or premises and relations, with a few notable differences: First, a relation can have multiple premises as source to model Cooperative supporting relations between premises (\autoref{fig:cooperative}). Second, a relation can target another relation. This is needed to encode the warranted support relation (\autoref{fig:warrantedsupport}).

\paragraph{Merging claims} At the end of every grammar rule the matched structures are merged. For rules that combine a few words into an \emph{object} this merely involves combining the spans of text into a single span that encompasses both (i.e. `the' + `man' becomes `the man') but when combining sentences the argument structures need to be merged. During this merge premises that were repeated in the text are merged into a single node in the argument graph.

\begin{enumerate}
    \item All premises from both arguments to be merged are added to the list as a pair consisting of the premise id and the premise itself.
    \item Each premise that occurs multiple times in the list is then replaced with the first occurrence.
    \item The list is used to replace all occurrences of the replaced premises with their replacement in the relations.
    \item The resulting set of unique premises and up-to-date relations is used to create a new argument, the result which is yielded after finishing the grammar rule.
\end{enumerate}

\paragraph{Grammar} We start with describing the grammar and parsing process for the basic support and attack relations.

\begin{grammar}
<argument> ::= <premise> `because' <minor-premise> % *> a <~ b

<argument> ::= <premise> `but' <minor-premise> % *> a *~ b
\end{grammar}

\noindent After parsing the rule in a text the argument structure is formed. If we use $a$ and $b$ to denote the text that matched \texttt{<premise>} and \texttt{<minor-premise>} we can describe the argument yielded by matching the first rule as follows: It consists of two premises, $a$ and $b$, and a relation $a <~ b$.

We make the distinction between minor and major premises: minor premises are statements about someone or something particular, e.g. Tweety, Socrates, and `the object' in our examples. Major premises are claims of a more general or generative nature: they are more rule-like and express expectations, for example that birds can fly or that men are mortal.

Minor and major premises we detect in HASL/0 using the following grammar. We use \texttt{<x>} with lower case $x$ to refer to other grammar rules, \texttt{<X>} with upper case $X$ to denote a token that matches one of the part-of-speech tags from \autoref{table:postags}, and \texttt{`x'} to indicate that the token is just the string `x'.

\begin{table}
    \begin{tabular}{lll}
        Tag & Description & Example \\
        \hline
        NN  & noun, singular & bird \\
        NNS & noun, plural & birds \\
        NNP & noun, proper singular & Socrates \\
        MD  & verb, modal auxiliary & can \\
        VBZ & verb, 3rd person singular present \\
        VBP & verb, non-3rd person singular present & are \\
        VBN & verb, past particle & illuminated \\
        DT  & determiner & the, a \\
        JJ  & adjective & red \\
        IN  & preposition & in, on, by \\
        RB  & adverb & not
    \end{tabular}
    \caption{Part-of-speech tags used in HASL, part of the Penn Treebank tag set.}
    \label{table:postags}
\end{table}

\begin{enumerate}
    \item `The man is mortal' and `Socrates is mortal'
    \begin{grammar}
        <minor-premise> ::= <instance> <VBZ> [<RB>] <object>
    \end{grammar}
    \item `Tweety can fly'
    \begin{grammar}
        <minor-premise> ::= <instance> <MD> [<RB>] <VB>
    \end{grammar}

    \item `A man is mortal'
    \begin{grammar}
        <major-premise> ::= <prototype-sg> <VBZ> [<RB>] <object>
    \end{grammar}
    \item `A bird can fly'
    \begin{grammar}
        <major-premise> ::= <prototype-sg> <MD> [<RB>] <VB>
    \end{grammar}
    \item Men are mortal
    \begin{grammar}
        <major-premise> ::= <prototype-pl> <VBP> [<RB>] <object>
    \end{grammar}
    \item Birds can fly
    \begin{grammar}
        <major-premise> ::= <prototype-pl> <MD> [<RB>] <VB>
    \end{grammar}
\end{enumerate}

These rules are supported by definitions for \texttt{object}, \texttt{instance} and the singular and plural versions of \texttt{prototype}. 

Objects are often the objects of sentences:

\begin{enumerate}
    \item `wings' in `Tweety has wings'
    \begin{grammar}
        <object> ::= <NN> \alt <NNS>
    \end{grammar}

    \item `red' in `the object is red'
    \begin{grammar}
        <object> ::= <JJ>
    \end{grammar}

    \item `the object' or `an object'
    \begin{grammar}
        <object> ::= <DT> <NN>
    \end{grammar}

    \item `the red light'
    \begin{grammar}
        <object> ::= <DT> <JJ> <NN>
    \end{grammar}

    \item `illuminated by a red light' for `the light is â€¦'
    \begin{grammar}
        <object> ::= <vbn>

        <vbn> ::= <VBN>
        \alt <VBN> <preposition-phrase>

        <preposition-phrase> ::= <IN> <NNP>
        \alt <IN> <object>
    \end{grammar}
\end{enumerate}

Instances are names, nouns which are preceded by a definite determiner (e.g. `the', `this') and pronouns referring to them such as `he' and `it'.

\begin{grammar}
<instance> ::= <NNP>
\alt <PRP>
\alt <definite-dt> <NN>
\alt <definite-dt> <NNP>

<definite-dt> ::= `the' \alt `this'
\end{grammar}

Prototypes are the indefinite variant of these. Since major premises both often occur as singular and as plural premises we add grammar rules for both. For minor premises we only implement the singular form.

\begin{grammar}
<prototype-sg> ::= <indefinite-dt> <NN>
\alt <indefinite-dt> <NN> <vbn>

<prototype-pl> ::= <NNS>
\alt <NNS> <vbn>

<indefinite-dt> ::= `a'
\end{grammar}

\paragraph{Sentences} Finally, an argumentative text in HASL's language consists of one or more sentences which combine the argument structures into a single argument.

\begin{grammar}
<sentences> ::= <sentences> <sentence>
    \alt <sentence>

<sentence> ::= <argument> `.'
\end{grammar}

\paragraph{Support} The grammar for supporting and attacking premises is incomplete, as it cannot be used to create the cooperative relations. We redefine the support and attack grammar rules to accept one or multiple reasons.

\begin{grammar}
<argument> ::= <premise> `because' <minor-premises> % a <~ b+

<argument> ::= <premise> `but' <minor-premises> % a *~ b+

<minor-premises> ::= <minor-premise>
\alt <minor-premise-list> `and' <minor-premise>

<minor-premise-list> ::= <minor-premise>
\alt <minor-premise-list> `,' <minor-premise>
\end{grammar}

\noindent Using these rules we can already form all argument structures depicted in \autoref{fig:proscons}, either directly or by repeating premises in multiple sentences.

\paragraph{Warranted support and attack} Warranted support and attack combines the usage of the major and minor premise.

\begin{grammar}
<argument> ::= <premise> `because' <minor-premise-list> `and' <major-premise> % (a <~ b+) <~ c

<argument> ::= <premise> `because' <major-premise> `and' <minor-premises> % (a <~ c+) <~ b

<argument> ::= <premise> `but' <minor-premise-list> `and' <major-premise> % (a *~ b+) <~ c

<argument> ::= <premise> `but' <major-premise> `and' <minor-premises> % (a *~ c+) <~ b
\end{grammar}

\noindent These rules effectively add two relations to the argument: one from the minor premises supporting or attacking the conclusion, and one from the major premise supporting the previous relation.

There is no \texttt{major-premise-list} or a way to add multiple major premises to a support relation as we only expect at most one major premise to be relevant per relation.

\paragraph{Undercutter} Lastly we need an extra rule to express the undercutter, as we currently have no way to express an attack on a relation.

\begin{grammar}
<argument> ::= <premise> `because' <minor-premises> `but' <premise> % (a <~ b+) *~ c
\end{grammar}

\paragraph{Result} The resulting grammar is unambiguous: There is only one way for each of the elements of the argument structure to be expressed. For simple examples it is very effective:

\begin{exe}
    \ex Socrates is mortal because he is a man and men are mortal.
    \ex The object is red because the object appears red but it is illuminated by a red light.
\end{exe}

\paragraph{Discussion}
Other structures, such as the chaining or arguments (\autoref{fig:chained}) and two arguments attacking each other (\autoref{fig:mutual}) are verbose to express:

\begin{exe}
    \ex\label{ex:hasl0tbw} Tweety can fly because he is a bird. He is a bird because he has wings.
    \ex\label{ex:hasl0tbnottb} Tweety is a bird but Tweety is not a bird. Tweety is not a bird but Tweety is a bird.
\end{exe}

\noindent Next to that the anaphora in example \ref{ex:hasl0tbw} also occur in the boxes, making the argument more difficult to understand as the order of the sentence, which we normally use to resolve anaphora, is no longer present. If there would be two or more individuals that can be referred to, there is no way to find out to which of these the pronoun referred.

The pronouns also make merging claims more difficult. For examples~\ref{ex:hasl0tbw} and~\ref{ex:hasl0tbnottb} to work the premise needs to be exactly the same. If we would start the second sentence in example~\ref{ex:hasl0tbw} with `Tweety' instead of `He', they would not have been merged into a single box in the argument structure. Having anaphora resolution happen before trying to merge the premises would help this process.
